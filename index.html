<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Flappy Bird </title>
  <style>
    :root{--bg:#70c5ce;--ground:#ded895;--pipe:#2e8b57;--bird:#ffdd57}
    html,body{height:100%;margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,"Helvetica Neue",Arial}
    body{display:flex;align-items:center;justify-content:center;background:linear-gradient(#9be3e6,var(--bg));}
    .wrap{width:420px;max-width:92vw;background:linear-gradient(#eef,#fff);border-radius:12px;padding:12px;box-shadow:0 8px 30px rgba(0,0,0,.15);}    
    canvas{display:block;border-radius:6px;background:linear-gradient(#bfe7ea,#7fd1d7);width:100%;height:auto}
    .info{display:flex;justify-content:space-between;align-items:center;margin-top:8px}
    .btn{padding:6px 10px;border-radius:8px;border:0;background:#333;color:white;cursor:pointer;font-weight:600}
    .hint{font-size:13px;color:#333;opacity:.8}
  </style>
</head>
<body>
  <div class="wrap">
    <canvas id="game" width="400" height="600"></canvas>
    <div class="info">
      <div class="hint">Espaço / Clique / Toque — para bater as asas</div>
      <div>
        <button id="restart" class="btn">Reiniciar</button>
      </div>
    </div>
  </div>

  <script>
  // Flappy Bird em JS puro — um arquivo só. Fácil de entender e modificar.
  (function(){
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const W = canvas.width; const H = canvas.height;

    // --- Configuráveis ---
    const gravity = 0.55;
    const flapStrength = -9.5;
    const pipeSpeed = 2.2;
    const pipeGap = 140; // distância vertical entre canos
    const pipeSpacing = 220; // distância horizontal entre canos
    const pipeWidth = 60;

    // --- Estado do jogo ---
    let bird = { x: 80, y: H/2, vy: 0, radius: 14 };
    let pipes = []; // array de {x, topHeight}
    let frame = 0;
    let score = 0;
    let best = 0;
    let playing = false;
    let gameOver = false;

    // --- Inicialização ---
    reset();

    function reset(){
      bird = { x: 80, y: H/2, vy: 0, radius: 14 };
      pipes = [];
      frame = 0;
      score = 0;
      playing = false;
      gameOver = false;
      spawnInitialPipes();
      draw();
    }

    function spawnInitialPipes(){
      pipes = [];
      // preenche alguns canos à direita
      for(let i=1;i<=3;i++){
        const x = W + i*pipeSpacing;
        pipes.push({ x, top: randBetween(60, H - pipeGap - 120), passed:false });
      }
    }

    function randBetween(a,b){ return Math.floor(Math.random()*(b-a+1))+a }

    // --- Controles ---
    function flap(){
      if(gameOver) return;
      bird.vy = flapStrength;
      playing = true;
    }

    window.addEventListener('keydown', (e)=>{ if(e.code==='Space'){ e.preventDefault(); flap(); } });
    canvas.addEventListener('mousedown', flap);
    canvas.addEventListener('touchstart', (e)=>{ e.preventDefault(); flap(); }, {passive:false});

    document.getElementById('restart').addEventListener('click', ()=>{ reset(); });

    // --- Lógica do jogo ---
    function update(){
      if(playing && !gameOver){
        frame++;

        // movimento do pássaro
        bird.vy += gravity;
        bird.y += bird.vy;

        // move canos
        for(let p of pipes){
          p.x -= pipeSpeed;
        }

        // spawn de novos canos
        const last = pipes[pipes.length-1];
        if(last && last.x < W - pipeSpacing){
          pipes.push({ x: W, top: randBetween(60, H - pipeGap - 120), passed:false });
        }

        // remove canos fora da tela
        if(pipes.length && pipes[0].x < -pipeWidth - 20) pipes.shift();

        // colisão com chão/ceiling
        if(bird.y + bird.radius > H - 40){ // chão imaginário a 40px do fim
          bird.y = H - 40 - bird.radius;
          endGame();
        }
        if(bird.y - bird.radius < 0){ bird.y = bird.radius; bird.vy = 0; }

        // colisão com canos e pontuação
        for(let p of pipes){
          // pontos quando passar do cano
          if(!p.passed && p.x + pipeWidth < bird.x - bird.radius){ p.passed = true; score++; if(score>best) best = score; }

          // colisão: bird dentro do x-range do cano?
          if(bird.x + bird.radius > p.x && bird.x - bird.radius < p.x + pipeWidth){
            // se estiver acima do gap ou abaixo do gap -> colisão
            if(bird.y - bird.radius < p.top || bird.y + bird.radius > p.top + pipeGap){
              endGame();
            }
          }
        }
      }
    }

    function endGame(){
      gameOver = true;
      playing = false;
      // mantém melhor pontuação no localStorage
      try{ localStorage.setItem('flappy_best', String(best)); }catch(e){}
    }

    // --- Desenho ---
    function draw(){
      // céu
      ctx.clearRect(0,0,W,H);

      // fundo com gradiente simples já no CSS do canvas

      // canos
      for(let p of pipes){
        drawPipe(p.x, 0, pipeWidth, p.top, true);
        drawPipe(p.x, p.top + pipeGap, pipeWidth, H - (p.top + pipeGap) - 40, false);
      }

      // chão
      ctx.fillStyle = 'var(--ground)';
      ctx.fillRect(0, H-40, W, 40);

      // pássaro (círculo) com asa simples
      drawBird();

      // HUD: score
      ctx.fillStyle = '#023';
      ctx.font = '40px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText(String(score), W/2, 70);

      // instruções quando não jogando
      if(!playing && !gameOver){
        ctx.fillStyle = 'rgba(0,0,0,0.6)';
        ctx.font = '18px sans-serif';
        ctx.fillText('Pressione Espaço ou Clique para começar', W/2, H/2 - 20);
      }

      // game over
      if(gameOver){
        ctx.fillStyle = 'rgba(0,0,0,0.6)';
        ctx.font = '36px sans-serif';
        ctx.fillText('Game Over', W/2, H/2 - 10);
        ctx.font = '18px sans-serif';
        ctx.fillText('Clique em Reiniciar para tentar de novo', W/2, H/2 + 22);
        ctx.fillText('Score: ' + score + ' • Best: ' + best, W/2, H/2 + 54);
      }

      requestAnimationFrame(draw);
    }

    function drawPipe(x,y,w,h,isTop){
      ctx.fillStyle = 'var(--pipe)';
      ctx.fillRect(x, y, w, h);
      // capa do cano (borda arredondada)
      ctx.fillStyle = shadeColor(getComputedStyle(document.documentElement).getPropertyValue('--pipe').trim(), -12);
      if(isTop){ ctx.fillRect(x-6, h-10, w+12, 16); }
      else{ ctx.fillRect(x-6, y-6, w+12, 16); }
    }

    function drawBird(){
      // corpo
      ctx.beginPath(); ctx.fillStyle = 'var(--bird)'; ctx.arc(bird.x, bird.y, bird.radius, 0, Math.PI*2); ctx.fill();
      // olho
      ctx.beginPath(); ctx.fillStyle = '#222'; ctx.arc(bird.x+6, bird.y-4, 3.2, 0, Math.PI*2); ctx.fill();
      // asa (um pequeno arco afiado)
      ctx.beginPath(); ctx.fillStyle = 'rgba(0,0,0,0.08)'; ctx.ellipse(bird.x-2, bird.y+2, 9, 5, Math.PI/6, 0, Math.PI*2); ctx.fill();
    }

    // pequena utilidade para escurecer cor (aceita formato #rrggbb)
    function shadeColor(hex, percent) {
      // remove # se houver
      hex = hex.replace('#','');
      if(hex.length!==6) return hex;
      const num = parseInt(hex,16);
      const r = Math.min(255, Math.max(0, (num >> 16) + percent));
      const g = Math.min(255, Math.max(0, ((num >> 8) & 0x00FF) + percent));
      const b = Math.min(255, Math.max(0, (num & 0x0000FF) + percent));
      return '#' + (r.toString(16).padStart(2,'0')) + (g.toString(16).padStart(2,'0')) + (b.toString(16).padStart(2,'0'));
    }

    // --- Loop de atualização separado para estabilidade ---
    setInterval(update, 1000/60); // 60 updates por segundo

    // tenta carregar melhor score
    try{ best = Number(localStorage.getItem('flappy_best')) || 0; }catch(e){ best = 0 }

    // desenhar pela primeira vez
    draw();
  })();
  </script>
</body>
</html>
